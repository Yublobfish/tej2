import { Observable, BehaviorSubject } from 'rxjs';
import { SetAttributeInput, SubAttributesPayload } from '@empirica/tajriba';

declare type JsonValue = string | number | boolean | Date | Json | JsonArray | null;
interface Json {
    [x: string]: JsonValue;
}
interface JsonArray extends Array<JsonValue> {
}

interface AttributeChange {
    /** deleted is true with the attribute was deleted. */
    deleted?: boolean;
    /** deletedAt is the time when the Attribute was deleted. int64 Date + Time
     * value given in Epoch with ns precision */
    deletedAt?: number;
    /** id is the identifier for the Attribute. */
    id: string;
    /** index is the index of the attribute if the value is a vector. */
    index?: number | null;
    /** isNew is true if the Attribute was just created. */
    isNew?: boolean;
    /** key is the attribute key being updated. */
    key: string;
    /** nodeID is the identifier for the Attribute's Node. */
    nodeID?: string;
    /** node is the Attribute's Node. */
    node?: {
        __typename: "Scope";
        id: string;
        kind?: string;
        name?: string;
    };
    /** value is the value of the updated attribute. */
    val?: string | null;
    /** vector indicates whether the value is a vector. */
    vector: boolean;
    /** version is the version number of this Attribute, starting at 1. */
    version: number;
}
interface AttributeUpdate {
    attribute: AttributeChange;
    removed: boolean;
}
declare class Attributes {
    readonly setAttributes: (input: SetAttributeInput[]) => Promise<unknown>;
    protected attrs: Map<string, Map<string, Attribute>>;
    protected updates: Map<string, Map<string, boolean | AttributeChange>>;
    constructor(attributesObs: Observable<AttributeUpdate>, donesObs: Observable<void>, setAttributes: (input: SetAttributeInput[]) => Promise<unknown>);
    attribute(scopeID: string, key: string): Attribute;
    attributes(scopeID: string): Attribute[];
    attributePeek(scopeID: string, key: string): Attribute | undefined;
    nextAttributeValue(scopeID: string, key: string): JsonValue | undefined;
    private update;
    scopeWasUpdated(scopeID?: string): boolean;
    protected next(): void;
}
interface AttributeOptions {
    /**
     * Private indicates the attribute will not be visible to other Participants.
     */
    private: boolean;
    /**
     * Protected indicates the attribute will not be updatable by other
     * Participants.
     */
    protected: boolean;
    /** Immutable creates an Attribute that cannot be updated. */
    immutable: boolean;
    /** Vector indicates the value is a vector. */
    vector: boolean;
    /**
     * Index, only used if the Attribute is a vector, indicates which index to
     * update the value at.
     */
    index: number | null;
    /**
     * Append, only used if the Attribute is a vector, indicates to append the
     * attribute to the vector.
     */
    append: boolean | null;
}
declare class Attribute {
    private setAttributes;
    readonly scopeID: string;
    readonly key: string;
    private attr?;
    private val;
    constructor(setAttributes: (input: SetAttributeInput[]) => Promise<unknown>, scopeID: string, key: string);
    get id(): string | undefined;
    get obs(): Observable<JsonValue | undefined>;
    get value(): JsonValue | undefined;
    get nodeID(): string | undefined;
    set(value: JsonValue, ao?: Partial<AttributeOptions>): void;
    _update(attr?: AttributeChange): void;
}

declare type Constructor<T extends {} = {}> = new (...args: any[]) => T;

declare type Attributable = {
    get: (key: string) => JsonValue | undefined;
    set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions>) => void;
};
interface ScopeIdent {
    id: string;
    kind: string;
}
interface ScopeUpdate {
    scope: ScopeIdent;
    removed: boolean;
}
declare type ScopeConstructor<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> = Constructor<Scope<Context, Kinds>>;
declare class Scopes<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}, Skope extends Scope<Context, Kinds> = Scope<Context, Kinds>> {
    protected ctx: Context;
    protected kinds: Kinds;
    protected attributes: Attributes;
    protected scopes: Map<string, BehaviorSubject<Skope>>;
    protected scopesByKind: Map<keyof Kinds, Map<string, Skope>>;
    protected kindUpdated: Set<keyof Kinds>;
    constructor(scopesObs: Observable<ScopeUpdate>, donesObs: Observable<void>, ctx: Context, kinds: Kinds, attributes: Attributes);
    scope(id: string): Skope | undefined;
    scopeObs(id: string): Observable<Skope> | undefined;
    byKind<T extends Skope>(kind: keyof Kinds): Map<string, T>;
    kindWasUpdated(kind: keyof Kinds): boolean;
    protected next(): void;
    protected update(scope: ScopeIdent, removed: boolean): void;
    protected create(scopeClass: ScopeConstructor<Context, Kinds>, scope: ScopeIdent): Skope;
}
declare class Scope<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> {
    constructor(
    /**
     * @internal
     */
    ctx: Context, 
    /**
     * @internal
     */
    scope: ScopeIdent, 
    /**
     * @internal
     */
    attributes: Attributes);
    get id(): string;
    get(key: string): JsonValue | undefined;
    getAttribute(key: string): Attribute | undefined;
    obs(key: string): Observable<JsonValue | undefined>;
    set(key: string, value: JsonValue, ao?: Partial<AttributeOptions>): void;
    inspect(): {
        [key: string]: JsonValue | undefined;
    };
}

declare class Globals {
    protected attrs: Map<string, BehaviorSubject<JsonValue | undefined>>;
    private updates;
    self: BehaviorSubject<Globals>;
    constructor(globals: Observable<SubAttributesPayload>);
    get(key: string): JsonValue | undefined;
    obs(key: string): BehaviorSubject<JsonValue | undefined>;
}

export { Attributes as A, Constructor as C, Globals as G, JsonValue as J, ScopeConstructor as S, Attribute as a, AttributeOptions as b, Scopes as c, ScopeUpdate as d, ScopeIdent as e, Scope as f, Attributable as g, AttributeUpdate as h };
