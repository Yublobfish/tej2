import {
  warn
} from "./chunk-I6L7V5LM.js";

// src/shared/scopes.ts
import { BehaviorSubject } from "rxjs";
var Scopes = class {
  constructor(scopesObs, donesObs, ctx, kinds, attributes) {
    this.ctx = ctx;
    this.kinds = kinds;
    this.attributes = attributes;
    this.scopes = /* @__PURE__ */ new Map();
    this.scopesByKind = /* @__PURE__ */ new Map();
    this.kindUpdated = /* @__PURE__ */ new Set();
    scopesObs.subscribe({
      next: ({ scope, removed }) => {
        this.update(scope, removed);
      }
    });
    donesObs.subscribe({
      next: this.next.bind(this)
    });
  }
  scope(id) {
    var _a;
    return (_a = this.scopes.get(id)) == null ? void 0 : _a.getValue();
  }
  scopeObs(id) {
    return this.scopes.get(id);
  }
  byKind(kind) {
    let map = this.scopesByKind.get(kind);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, map);
    }
    return map;
  }
  kindWasUpdated(kind) {
    return this.kindUpdated.has(kind);
  }
  next() {
    this.kindUpdated.clear();
    for (const [_, scopeSubject] of this.scopes) {
      const scope = scopeSubject.getValue();
      if (scope._updated || this.attributes.scopeWasUpdated(scope.id)) {
        scope._updated = false;
        scopeSubject.next(scope);
      }
    }
  }
  update(scope, removed) {
    var _a;
    const existing = (_a = this.scopes.get(scope.id)) == null ? void 0 : _a.getValue();
    if (removed) {
      if (!existing) {
        warn("scopes: missing scope on removal", scope.id, scope.kind);
        return;
      }
      existing._deleted = true;
      existing._updated = true;
      this.scopes.delete(scope.id);
      if (!scope.kind) {
        warn("scopes: scope missing kind on scope on removal");
        return;
      }
      const kind2 = scope.kind;
      this.scopesByKind.get(kind2).delete(scope.id);
      this.kindUpdated.add(kind2);
      return;
    }
    if (existing) {
      existing._deleted = false;
      return;
    }
    if (!scope.kind) {
      warn("scopes: scope missing kind on scope");
      return;
    }
    const kind = scope.kind;
    const scopeClass = this.kinds[kind];
    if (!scopeClass) {
      warn(`scopes: unknown scope kind: ${scope.kind}`);
      return;
    }
    const obj = this.create(scopeClass, scope);
    const subj = new BehaviorSubject(obj);
    this.scopes.set(scope.id, subj);
    let skm = this.scopesByKind.get(kind);
    if (!skm) {
      skm = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, skm);
    }
    skm.set(scope.id, obj);
    obj._updated = true;
    this.kindUpdated.add(kind);
  }
  create(scopeClass, scope) {
    return new scopeClass(this.ctx, scope, this.attributes);
  }
};
var Scope = class {
  constructor(ctx, scope, attributes) {
    this.ctx = ctx;
    this.scope = scope;
    this.attributes = attributes;
    this._deleted = false;
    this._updated = false;
  }
  get id() {
    return this.scope.id;
  }
  get kind() {
    return this.scope.kind;
  }
  get(key) {
    return this.attributes.attribute(this.scope.id, key).value;
  }
  getAttribute(key) {
    return this.attributes.attribute(this.scope.id, key);
  }
  obs(key) {
    return this.attributes.attribute(this.scope.id, key).obs;
  }
  set(key, value, ao) {
    return this.attributes.attribute(this.scope.id, key).set(value, ao);
  }
  inspect() {
    const attrs = this.attributes.attributes(this.scope.id);
    const out = {};
    for (const attr of attrs) {
      out[attr.key] = attr.value;
    }
    return out;
  }
  hasUpdated() {
    return this._updated || this.attributes.scopeWasUpdated(this.id);
  }
};

export {
  Scopes,
  Scope
};
//# sourceMappingURL=chunk-TSO4LTDH.js.map