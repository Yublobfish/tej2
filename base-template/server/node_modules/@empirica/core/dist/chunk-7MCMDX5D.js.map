{"version":3,"sources":["../src/admin/attributes.ts","../src/admin/connection.ts","../src/admin/participants.ts","../src/admin/subscriptions.ts","../src/admin/transitions.ts"],"sourcesContent":["import { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  Attribute,\n  AttributeChange,\n  Attributes as SharedAttributes,\n} from \"../shared/attributes\";\nimport { warn } from \"../utils/console\";\n\nexport type AttributeMsg = {\n  attribute?: Attribute;\n  done: boolean;\n};\n\nexport class Attributes extends SharedAttributes {\n  protected attrsByKind = new Map<\n    string,\n    Map<string, Map<string, Attribute>>\n  >();\n  private attribSubs = new Map<\n    string,\n    Map<string, ReplaySubject<AttributeMsg>>\n  >();\n\n  subscribeAttribute(kind: string, key: string): Observable<AttributeMsg> {\n    if (!this.attribSubs.has(kind)) {\n      this.attribSubs.set(kind, new Map<string, ReplaySubject<AttributeMsg>>());\n    }\n\n    const keyMap = this.attribSubs.get(kind)!;\n    let sub = keyMap.get(key);\n    if (!sub) {\n      sub = new ReplaySubject<AttributeMsg>();\n      keyMap.set(key, sub);\n\n      const attrByScopeID = this.attrsByKind.get(kind);\n\n      setTimeout(() => {\n        if (!attrByScopeID) {\n          sub!.next({ done: true });\n          return;\n        }\n\n        let attrs = [];\n        for (const [_, attrByKey] of attrByScopeID?.entries()) {\n          for (const [_, attr] of attrByKey) {\n            if (attr.key === key) {\n              attrs.push(attr);\n            }\n          }\n        }\n\n        if (attrs.length > 0) {\n          let count = 0;\n          for (const attr of attrs) {\n            count++;\n            sub!.next({ attribute: attr, done: count == attrs.length });\n          }\n        } else {\n          sub!.next({ done: true });\n        }\n      }, 0);\n    }\n\n    return sub!;\n  }\n\n  protected next() {\n    const byKind = new Map<string, AttributeChange[]>();\n\n    for (const [_, attrs] of this.updates) {\n      for (const [_, attr] of attrs) {\n        if (typeof attr === \"boolean\") {\n          continue;\n        }\n\n        const kind = attr.node?.kind;\n        if (kind) {\n          let kindAttrs = byKind.get(kind);\n          if (!kindAttrs) {\n            kindAttrs = [];\n            byKind.set(kind, kindAttrs);\n          }\n\n          kindAttrs.push(attr);\n        }\n      }\n    }\n\n    const updates: [string, string, AttributeChange][] = [];\n    for (const [kind, attrs] of byKind) {\n      for (const attr of attrs) {\n        // This is very difficult to reproduce in tests since this.updates\n        // cannot contain an AttributeChange that would satisfy this.\n        /* c8 ignore next 4 */\n        if (!attr.nodeID && !attr.node?.id) {\n          warn(`found attribute change without node ID`);\n          continue;\n        }\n        updates.push([kind, attr.key, attr]);\n      }\n    }\n\n    super.next();\n\n    for (const [kind, key, attrChange] of updates) {\n      // Forcing nodeID because we already tested it above.\n      const nodeID = attrChange.nodeID || attrChange.node!.id;\n\n      // Forcing attr because we already tested it above.\n      const attr = this.attrs.get(nodeID)!.get(key)!;\n      const sub = this.attribSubs.get(kind)?.get(key);\n      if (sub) {\n        sub.next({ attribute: attr, done: true });\n      } else {\n        let kAttrs = this.attrsByKind.get(kind);\n        if (!kAttrs) {\n          kAttrs = new Map<string, Map<string, Attribute>>();\n          this.attrsByKind.set(kind, kAttrs);\n        }\n\n        let kkAttrs = kAttrs!.get(nodeID);\n        if (!kkAttrs) {\n          kkAttrs = new Map<string, Attribute>();\n          kAttrs!.set(nodeID, kkAttrs);\n        }\n\n        kkAttrs.set(key, attr);\n      }\n    }\n  }\n}\n","import { TajribaAdmin } from \"@empirica/tajriba\";\nimport { BehaviorSubject, merge, SubscriptionLike } from \"rxjs\";\nimport {\n  ErrNotConnected,\n  TajribaConnection,\n} from \"../shared/tajriba_connection\";\nimport { bs, bsu } from \"../utils/object\";\nimport { subscribeAsync } from \"./observables\";\n\nexport class AdminConnection {\n  private _tajriba = bsu<TajribaAdmin>();\n  private _connected = bs(false);\n  private _connecting = bs(false);\n  private _stopped = bs(false);\n  private sub: SubscriptionLike;\n\n  constructor(\n    taj: TajribaConnection,\n    tokens: BehaviorSubject<string | null | undefined>,\n    private resetToken: () => void\n  ) {\n    let token: string | null | undefined;\n    let connected = false;\n\n    this.sub = subscribeAsync(\n      merge(taj.connected, tokens),\n      async (tokenOrConnected) => {\n        if (typeof tokenOrConnected === \"boolean\") {\n          connected = tokenOrConnected;\n        } else {\n          token = tokenOrConnected;\n        }\n\n        if (!token || !connected) {\n          return;\n        }\n\n        if (this._connected.getValue()) {\n          return;\n        }\n\n        this._connecting.next(true);\n\n        try {\n          const tajAdmin = await taj.sessionAdmin(token);\n\n          this._tajriba.next(tajAdmin);\n          this._connected.next(true);\n\n          tajAdmin.on(\"connected\", () => {\n            if (!this._connected.getValue()) {\n              this._connected.next(true);\n            }\n          });\n          tajAdmin.on(\"disconnected\", () => {\n            if (this._connected.getValue()) {\n              this._connected.next(false);\n            }\n          });\n          tajAdmin.on(\"accessDenied\", () => {\n            if (this._connected.getValue()) {\n              this._connected.next(false);\n            }\n            this.resetToken();\n          });\n        } catch (error) {\n          if (error !== ErrNotConnected) {\n            this.resetToken();\n          }\n        }\n\n        this._connecting.next(false);\n      }\n    );\n  }\n\n  stop() {\n    if (this._stopped.getValue()) {\n      return;\n    }\n\n    const taj = this._tajriba.getValue();\n    if (taj) {\n      taj.removeAllListeners(\"connected\");\n      taj.removeAllListeners(\"disconnected\");\n      taj.stop();\n      this._tajriba.next(undefined);\n    }\n\n    this.sub.unsubscribe();\n\n    this._connecting.next(false);\n    this._connected.next(false);\n    this._stopped.next(true);\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  get stopped() {\n    return this._stopped;\n  }\n\n  get admin() {\n    return this._tajriba;\n  }\n}\n","import { EventType, TajribaAdmin } from \"@empirica/tajriba\";\nimport { Subject } from \"rxjs\";\nimport { error } from \"../utils/console\";\nimport { PromiseHandle, promiseHandle } from \"./promises\";\n\nexport interface Participant {\n  id: string;\n  identifier: string;\n}\n\nexport interface Connection {\n  participant: Participant;\n  connected: boolean;\n}\n\nexport interface ConnectionMsg {\n  connection?: Connection;\n  done: boolean;\n}\n\nexport async function participantsSub(\n  taj: TajribaAdmin,\n  connections: Subject<ConnectionMsg>,\n  participants: Map<string, Participant>\n) {\n  let handle: PromiseHandle | undefined = promiseHandle();\n  taj.onEvent({ eventTypes: [EventType.ParticipantConnected] }).subscribe({\n    next({ node, done }) {\n      if (!node) {\n        if (done) {\n          if (handle) {\n            handle?.result();\n\n            connections.next({ done: true });\n          }\n\n          return;\n        }\n        error(`received no participant on connected`);\n\n        return;\n      }\n\n      if (node.__typename !== \"Participant\") {\n        error(`received non-participant on connected`);\n\n        return;\n      }\n\n      const part = {\n        id: node.id,\n        identifier: node.identifier,\n      };\n\n      participants.set(node.id, part);\n\n      connections.next({\n        connection: {\n          participant: part,\n          connected: true,\n        },\n        done,\n      });\n\n      if (handle && done) {\n        handle.result();\n      }\n    },\n  });\n\n  taj.onEvent({ eventTypes: [EventType.ParticipantDisconnect] }).subscribe({\n    next({ node }) {\n      if (!node) {\n        error(`received no participant on disconnect`);\n\n        return;\n      }\n\n      if (node.__typename !== \"Participant\") {\n        error(`received non-participant on disconnect`);\n\n        return;\n      }\n\n      participants.delete(node.id);\n\n      connections.next({\n        connection: {\n          participant: {\n            id: node.id,\n            identifier: node.identifier,\n          },\n          connected: false,\n        },\n        done: true,\n      });\n    },\n  });\n\n  await handle.promise;\n  handle = undefined;\n}\n","import { ScopeConstructor } from \"../shared/scopes\";\n\nexport type KV = {\n  key: string;\n  val: string;\n};\n\nfunction kvstr(kv: KV) {\n  return kv.key + \"-\" + kv.val;\n}\n\nexport interface ScopeSubscriptionInput {\n  /** ids of the matching Scopes. */\n  ids: string[];\n  /** kinds of the matching Scopes. */\n  kinds: string[];\n  /** keys to Attributes in matching Scope. */\n  keys: string[];\n  /** kvs to Attributes in matching Scope. */\n  kvs: KV[];\n  /** names of the matching Scopes. */\n  names: string[];\n}\n\nexport interface Subs {\n  participants: boolean;\n  scopes: {\n    ids: string[];\n    kinds: string[];\n    names: string[];\n    keys: string[];\n    kvs: KV[];\n  };\n  transitions: string[];\n}\n\n// Tracks what data should be subscribed to.\nexport class Subscriptions<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  private scopeKinds = new Set<string>();\n  private scopeIDs = new Set<string>();\n  private scopeNames = new Set<string>();\n  private scopeKeys = new Set<string>();\n  private scopeKVSet = new Set<string>();\n  private scopeKVs: KV[] = [];\n  private participantSub = false;\n  private transitionsSubs = new Set<string>();\n  private dirty = false;\n  public last: Subs = {\n    participants: false,\n    scopes: {\n      ids: [],\n      kinds: [],\n      names: [],\n      keys: [],\n      kvs: [],\n    },\n    transitions: [],\n  };\n\n  get subs(): Subs {\n    return {\n      participants: this.participantSub,\n      scopes: {\n        kinds: Array.from(this.scopeKinds.values()),\n        ids: Array.from(this.scopeIDs.values()),\n        names: Array.from(this.scopeNames.values()),\n        keys: Array.from(this.scopeKeys.values()),\n        kvs: [...this.scopeKVs],\n      },\n      transitions: Array.from(this.transitionsSubs.values()),\n    };\n  }\n\n  // newSubs will return only new subs since the last call.\n  newSubs(): Subs | undefined {\n    if (!this.dirty) {\n      return;\n    }\n\n    const current = this.subs;\n    const {\n      scopes: { ids, kinds, names, keys, kvs },\n      participants,\n      transitions,\n    } = this.last;\n\n    const kvsstrs = kvs.map((kv) => kvstr(kv));\n\n    const next = {\n      participants: this.participantSub && !participants,\n      scopes: {\n        ids: current.scopes.ids.filter((id) => !ids.includes(id)),\n        kinds: current.scopes.kinds.filter((kind) => !kinds.includes(kind)),\n        names: current.scopes.names.filter((name) => !names.includes(name)),\n        keys: current.scopes.keys.filter((key) => !keys.includes(key)),\n        kvs: current.scopes.kvs.filter((kv) => !kvsstrs.includes(kvstr(kv))),\n      },\n      transitions: current.transitions.filter(\n        (id) => !transitions.includes(id)\n      ),\n    };\n\n    this.last = current;\n    this.dirty = false;\n\n    return next;\n  }\n\n  scopeSub(input: Partial<ScopeSubscriptionInput>) {\n    if (input.ids) {\n      for (const id of input.ids) {\n        if (!this.scopeIDs.has(id)) {\n          this.scopeIDs.add(id);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.kinds) {\n      for (const id of input.kinds) {\n        if (!this.scopeKinds.has(id)) {\n          this.scopeKinds.add(id);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.names) {\n      for (const name of input.names) {\n        if (!this.scopeNames.has(name)) {\n          this.scopeNames.add(name);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.keys) {\n      for (const key of input.keys) {\n        if (!this.scopeKeys.has(key)) {\n          this.scopeKeys.add(key);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.kvs) {\n      for (const kv of input.kvs) {\n        const kvKey = kvstr(kv);\n        if (!this.scopeKVSet.has(kvKey)) {\n          this.scopeKVSet.add(kvKey);\n          this.scopeKVs.push(kv);\n          this.dirty = true;\n        }\n      }\n    }\n  }\n\n  participantsSub() {\n    if (!this.participantSub) {\n      this.dirty = true;\n      this.participantSub = true;\n    }\n  }\n\n  transitionsSub(nodeID: string) {\n    if (!this.transitionsSubs.has(nodeID)) {\n      this.transitionsSubs.add(nodeID);\n      this.dirty = true;\n    }\n  }\n}\n","import { EventType, State, TajribaAdmin } from \"@empirica/tajriba\";\nimport { Subject } from \"rxjs\";\nimport { error } from \"../utils/console\";\n\nexport interface Step {\n  id: string;\n  state: State;\n  duration: number;\n  startedAt?: number;\n  endedAt?: number;\n}\n\nexport interface Transition {\n  id: string;\n  from: State;\n  to: State;\n  step: Step;\n}\n\nexport function transitionsSub(\n  taj: TajribaAdmin,\n  transitions: Subject<Transition>,\n  nodeID: string\n) {\n  taj.onEvent({ eventTypes: [EventType.TransitionAdd], nodeID }).subscribe({\n    next({ node }) {\n      if (!node) {\n        return;\n      }\n\n      if (node.__typename !== \"Transition\") {\n        error(`received non-transition`);\n\n        return;\n      }\n\n      if (node.node.__typename !== \"Step\") {\n        error(`received non-step transition`, node.node);\n\n        return;\n      }\n\n      transitions.next({\n        id: node.id,\n        to: node.to,\n        from: node.from,\n        step: {\n          id: node.node.id,\n          duration: node.node.duration,\n          state: node.node.state,\n        },\n      });\n    },\n  });\n}\n"],"mappings":"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","names":["Attributes","_","error","EventType","EventType"]}