"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/player/index.ts
var player_exports = {};
__export(player_exports, {
  Attribute: () => Attribute,
  Attributes: () => Attributes,
  Globals: () => Globals,
  Scope: () => Scope2,
  Scopes: () => Scopes2,
  Step: () => Step,
  Steps: () => Steps,
  TajribaProvider: () => TajribaProvider,
  createNewParticipant: () => createNewParticipant,
  isDevelopment: () => isDevelopment,
  isProduction: () => isProduction,
  isTest: () => isTest
});
module.exports = __toCommonJS(player_exports);

// src/shared/attributes.ts
var import_rxjs = require("rxjs");

// src/utils/console.ts
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var logsMock;
var colorHex = {
  [1 /* Bold */]: "font-weight: bold",
  [30 /* Black */]: "color: #000000",
  [31 /* Red */]: "color: #cc0000",
  [32 /* Green */]: "color: #4e9a06",
  [33 /* Yellow */]: "color: #c4a000",
  [34 /* Blue */]: "color: #729fcf",
  [35 /* Magenta */]: "color: #75507b",
  [36 /* Cyan */]: "color: #06989a",
  [37 /* White */]: "color: #d3d7cf",
  [90 /* DarkGray */]: "color: #555753"
};
var levels = {
  trace: 0,
  debug: 1,
  log: 2,
  info: 2,
  warn: 3,
  error: 4
};
var reversLevels = {};
for (const key in levels) {
  reversLevels[levels[key]] = key;
}
var currentLevel = 2;
function formatConsoleDate(date, level) {
  var hour = date.getHours();
  var minutes = date.getMinutes();
  var seconds = date.getSeconds();
  var milliseconds = date.getMilliseconds();
  const str = (hour < 10 ? "0" + hour : hour) + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds) + "." + ("00" + milliseconds).slice(-3);
  if (isBrowser) {
    const ts = colorize(str, 90 /* DarkGray */).concat(level);
    return [ts[0] + " " + level[0], ts[1], level[1]];
  }
  return colorize(str, 90 /* DarkGray */).concat(level);
}
var createLogger = (lvl, level) => {
  return (...args) => {
    if (lvl < currentLevel) {
      return;
    }
    if (logsMock) {
      logsMock.log({ level: reversLevels[lvl], args });
      return;
    }
    if (args.length === 1) {
      switch (typeof args[0]) {
        case "string":
          for (const line of args[0].split("\n")) {
            console.log(...formatConsoleDate(new Date(), level).concat(line));
          }
          return;
        case "object":
          if (args[0] instanceof Error) {
            const error2 = args[0];
            const prettyErr = error2.name + ": " + error2.message.replace(new RegExp(`^${error2.name}[: ]*`), "") + "\n" + (error2.stack || "").split("\n").map((line) => line.trim()).map((line) => {
              if (line.startsWith(error2.name + ": " + error2.message))
                return null;
              if (line.startsWith("at")) {
                return "  " + line;
              }
              return line;
            }).filter(Boolean).join("\n");
            for (const line of prettyErr.split("\n")) {
              console.log(...formatConsoleDate(new Date(), level).concat(line));
            }
            return;
          }
      }
    }
    console.log(...formatConsoleDate(new Date(), level).concat(args));
  };
};
function colorize(s, ...cc) {
  if (isBrowser) {
    const attr = [];
    for (const c of cc) {
      attr.push(colorHex[c]);
    }
    return [`%c${s}`, attr.join("; ")];
  }
  let out = "";
  for (const c of cc) {
    out += `\x1B[${c}m`;
  }
  out += `${s}\x1B[0m`;
  return [out];
}
var trace = createLogger(0, colorize("TRC", 35 /* Magenta */));
var debug = createLogger(1, colorize("DBG", 33 /* Yellow */));
var log = createLogger(2, colorize("LOG", 33 /* Yellow */));
var info = createLogger(2, colorize("INF", 32 /* Green */));
var warn = createLogger(3, colorize("WRN", 36 /* Cyan */));
var error = createLogger(4, colorize("ERR", 31 /* Red */, 1 /* Bold */));

// src/shared/attributes.ts
var Attributes = class {
  constructor(attributesObs, donesObs, setAttributes) {
    this.setAttributes = setAttributes;
    this.attrs = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    attributesObs.subscribe({
      next: ({ attribute, removed }) => {
        this.update(attribute, removed);
      }
    });
    donesObs.subscribe({
      next: this.next.bind(this)
    });
  }
  attribute(scopeID, key) {
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.attrs.set(scopeID, scopeMap);
    }
    let attr = scopeMap.get(key);
    if (!attr) {
      attr = new Attribute(this.setAttributes, scopeID, key);
      scopeMap.set(key, attr);
    }
    return attr;
  }
  attributes(scopeID) {
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.attrs.set(scopeID, scopeMap);
    }
    return Array.from(scopeMap.values());
  }
  attributePeek(scopeID, key) {
    let scopeUpdateMap = this.updates.get(scopeID);
    if (scopeUpdateMap) {
      const updated = scopeUpdateMap.get(key);
      if (updated) {
        if (typeof updated === "boolean") {
          return;
        } else {
          if (!updated.val) {
            return;
          } else {
            const attr2 = new Attribute(this.setAttributes, scopeID, key);
            attr2._update(updated);
            return attr2;
          }
        }
      }
    }
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      return;
    }
    let attr = scopeMap.get(key);
    if (!attr) {
      return;
    }
    if (attr.value === void 0) {
      return;
    }
    return attr;
  }
  nextAttributeValue(scopeID, key) {
    const attr = this.attributePeek(scopeID, key);
    if (!attr) {
      return;
    }
    return attr.value;
  }
  update(attr, removed) {
    var _a;
    let nodeID = attr.nodeID;
    if (!nodeID) {
      if (!((_a = attr.node) == null ? void 0 : _a.id)) {
        error(`new attribute without node ID`);
        return;
      }
      nodeID = attr.node.id;
    }
    let scopeMap = this.updates.get(nodeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.updates.set(nodeID, scopeMap);
    }
    if (removed) {
      scopeMap.set(attr.key, true);
    } else {
      scopeMap.set(attr.key, attr);
    }
  }
  scopeWasUpdated(scopeID) {
    if (!scopeID) {
      return false;
    }
    return this.updates.has(scopeID);
  }
  next() {
    for (const [scopeID, attrs] of this.updates) {
      let scopeMap = this.attrs.get(scopeID);
      if (!scopeMap) {
        scopeMap = /* @__PURE__ */ new Map();
        this.attrs.set(scopeID, scopeMap);
      }
      for (const [key, attrOrDel] of attrs) {
        let attr = scopeMap.get(key);
        if (typeof attrOrDel === "boolean") {
          if (attr) {
            attr._update(void 0);
          }
        } else {
          if (!attr) {
            attr = new Attribute(this.setAttributes, scopeID, key);
            scopeMap.set(key, attr);
          }
          attr._update(attrOrDel);
        }
      }
    }
    this.updates.clear();
  }
};
var Attribute = class {
  constructor(setAttributes, scopeID, key) {
    this.setAttributes = setAttributes;
    this.scopeID = scopeID;
    this.key = key;
    this.val = new import_rxjs.BehaviorSubject(void 0);
  }
  get id() {
    var _a;
    return (_a = this.attr) == null ? void 0 : _a.id;
  }
  get obs() {
    return this.val;
  }
  get value() {
    return this.val.getValue();
  }
  get nodeID() {
    var _a, _b, _c;
    return ((_a = this.attr) == null ? void 0 : _a.nodeID) || ((_c = (_b = this.attr) == null ? void 0 : _b.node) == null ? void 0 : _c.id);
  }
  set(value, ao) {
    this.val.next(value);
    const attrProps = {
      key: this.key,
      nodeID: this.scopeID,
      val: JSON.stringify(value)
    };
    if (ao) {
      attrProps.private = ao.private;
      attrProps.protected = ao.protected;
      attrProps.immutable = ao.immutable;
      attrProps.append = ao.append;
      attrProps.vector = ao.vector;
      attrProps.index = ao.index;
    }
    this.setAttributes([attrProps]);
    trace(`SET ${this.key} = ${value} (${this.scopeID})`);
  }
  _update(attr) {
    var _a;
    if (attr && this.attr && this.attr.id === attr.id) {
      return;
    }
    this.attr = attr;
    let value = void 0;
    if ((_a = this.attr) == null ? void 0 : _a.val) {
      value = JSON.parse(this.attr.val);
    }
    this.val.next(value);
  }
};

// src/shared/globals.ts
var import_rxjs2 = require("rxjs");
var Globals = class {
  constructor(globals) {
    this.attrs = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    this.self = new import_rxjs2.BehaviorSubject(this);
    globals.subscribe({
      next: ({ attribute, done }) => {
        if (attribute) {
          let val = void 0;
          if (attribute.val) {
            val = JSON.parse(attribute.val);
          }
          this.updates.set(attribute.key, val);
        }
        if (done) {
          for (const [key, val] of this.updates) {
            this.obs(key).next(val);
          }
          this.updates.clear();
          if (this.self) {
            this.self.next(this);
          }
        }
      }
    });
  }
  get(key) {
    const o = this.attrs.get(key);
    if (o) {
      return o.getValue();
    }
    return void 0;
  }
  obs(key) {
    let o = this.attrs.get(key);
    if (!o) {
      o = new import_rxjs2.BehaviorSubject(void 0);
      this.attrs.set(key, o);
    }
    return o;
  }
};

// src/player/provider.ts
var import_rxjs3 = require("rxjs");
var TajribaProvider = class {
  constructor(changes, globals, setAttributes) {
    this.globals = globals;
    this.setAttributes = setAttributes;
    this.scopes = new import_rxjs3.Subject();
    this.attributes = new import_rxjs3.Subject();
    this.participants = new import_rxjs3.Subject();
    this.steps = new import_rxjs3.Subject();
    this.dones = new import_rxjs3.Subject();
    changes.pipe((0, import_rxjs3.groupBy)((chg) => chg.change.__typename)).subscribe({
      next: (group) => {
        switch (group.key) {
          case "ScopeChange":
            group.subscribe({
              next: (scope) => {
                this.scopes.next({
                  scope: scope.change,
                  removed: scope.removed
                });
                if (scope.done) {
                  this.dones.next();
                }
              }
            });
            break;
          case "AttributeChange":
            group.subscribe({
              next: (attribute) => {
                this.attributes.next({
                  attribute: attribute.change,
                  removed: attribute.removed
                });
                if (attribute.done) {
                  this.dones.next();
                }
              }
            });
            break;
          case "ParticipantChange":
            group.subscribe({
              next: (scope) => {
                this.participants.next({
                  participant: scope.change,
                  removed: scope.removed
                });
                if (scope.done) {
                  this.dones.next();
                }
              }
            });
            break;
          case "StepChange":
            group.subscribe({
              next: (scope) => {
                this.steps.next({
                  step: scope.change,
                  removed: scope.removed
                });
                if (scope.done) {
                  this.dones.next();
                }
              }
            });
            break;
        }
      }
    });
  }
};

// src/shared/scopes.ts
var import_rxjs4 = require("rxjs");
var Scopes = class {
  constructor(scopesObs, donesObs, ctx, kinds, attributes) {
    this.ctx = ctx;
    this.kinds = kinds;
    this.attributes = attributes;
    this.scopes = /* @__PURE__ */ new Map();
    this.scopesByKind = /* @__PURE__ */ new Map();
    this.kindUpdated = /* @__PURE__ */ new Set();
    scopesObs.subscribe({
      next: ({ scope, removed }) => {
        this.update(scope, removed);
      }
    });
    donesObs.subscribe({
      next: this.next.bind(this)
    });
  }
  scope(id) {
    var _a;
    return (_a = this.scopes.get(id)) == null ? void 0 : _a.getValue();
  }
  scopeObs(id) {
    return this.scopes.get(id);
  }
  byKind(kind) {
    let map2 = this.scopesByKind.get(kind);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, map2);
    }
    return map2;
  }
  kindWasUpdated(kind) {
    return this.kindUpdated.has(kind);
  }
  next() {
    this.kindUpdated.clear();
    for (const [_, scopeSubject] of this.scopes) {
      const scope = scopeSubject.getValue();
      if (scope._updated || this.attributes.scopeWasUpdated(scope.id)) {
        scope._updated = false;
        scopeSubject.next(scope);
      }
    }
  }
  update(scope, removed) {
    var _a;
    const existing = (_a = this.scopes.get(scope.id)) == null ? void 0 : _a.getValue();
    if (removed) {
      if (!existing) {
        warn("scopes: missing scope on removal", scope.id, scope.kind);
        return;
      }
      existing._deleted = true;
      existing._updated = true;
      this.scopes.delete(scope.id);
      if (!scope.kind) {
        warn("scopes: scope missing kind on scope on removal");
        return;
      }
      const kind2 = scope.kind;
      this.scopesByKind.get(kind2).delete(scope.id);
      this.kindUpdated.add(kind2);
      return;
    }
    if (existing) {
      existing._deleted = false;
      return;
    }
    if (!scope.kind) {
      warn("scopes: scope missing kind on scope");
      return;
    }
    const kind = scope.kind;
    const scopeClass = this.kinds[kind];
    if (!scopeClass) {
      warn(`scopes: unknown scope kind: ${scope.kind}`);
      return;
    }
    const obj = this.create(scopeClass, scope);
    const subj = new import_rxjs4.BehaviorSubject(obj);
    this.scopes.set(scope.id, subj);
    let skm = this.scopesByKind.get(kind);
    if (!skm) {
      skm = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, skm);
    }
    skm.set(scope.id, obj);
    obj._updated = true;
    this.kindUpdated.add(kind);
  }
  create(scopeClass, scope) {
    return new scopeClass(this.ctx, scope, this.attributes);
  }
};
var Scope = class {
  constructor(ctx, scope, attributes) {
    this.ctx = ctx;
    this.scope = scope;
    this.attributes = attributes;
    this._deleted = false;
    this._updated = false;
  }
  get id() {
    return this.scope.id;
  }
  get kind() {
    return this.scope.kind;
  }
  get(key) {
    return this.attributes.attribute(this.scope.id, key).value;
  }
  getAttribute(key) {
    return this.attributes.attribute(this.scope.id, key);
  }
  obs(key) {
    return this.attributes.attribute(this.scope.id, key).obs;
  }
  set(key, value, ao) {
    return this.attributes.attribute(this.scope.id, key).set(value, ao);
  }
  inspect() {
    const attrs = this.attributes.attributes(this.scope.id);
    const out = {};
    for (const attr of attrs) {
      out[attr.key] = attr.value;
    }
    return out;
  }
  hasUpdated() {
    return this._updated || this.attributes.scopeWasUpdated(this.id);
  }
};

// src/player/scopes.ts
var Scopes2 = class extends Scopes {
  constructor(scopesObs, donesObs, ctx, kinds, attributes, steps) {
    super(scopesObs, donesObs, ctx, kinds, attributes);
    this.steps = steps;
  }
  create(scopeClass, scope) {
    return new scopeClass(
      this.ctx,
      scope,
      this,
      this.attributes,
      this.steps
    );
  }
};
var Scope2 = class extends Scope {
  constructor(ctx, scope, scopes, attributes, steps) {
    super(ctx, scope, attributes);
    this.scopes = scopes;
    this.steps = steps;
  }
  scopeByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.scopes.scope(id);
  }
  ticker(id) {
    return this.steps.step(id);
  }
  tickerByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.ticker(id);
  }
};

// src/player/steps.ts
var import_rxjs5 = require("rxjs");
var scheduled = [];
var mockNow = null;
function pnow() {
  if (mockNow !== null) {
    return mockNow;
  } else {
    return performance.now();
  }
}
function timeout(callback, ms) {
  if (mockNow !== null) {
    const schd = {
      cb: callback,
      from: mockNow,
      dur: ms
    };
    scheduled.push(schd);
  } else {
    setTimeout(callback, ms);
  }
}
var Step = class {
  constructor(step, ticker) {
    this.running = false;
    this.ticker = new import_rxjs5.BehaviorSubject(void 0);
    this.startAt = 0;
    this.endAt = 0;
    ticker.pipe((0, import_rxjs5.map)(this.recalc.bind(this))).subscribe({
      next: (val) => {
        this.ticker.next(val);
      }
    });
    this._update(step);
  }
  recalc(t) {
    if (!this.running) {
      return void 0;
    }
    return {
      started: t >= this.startAt,
      ended: t >= this.endAt,
      elapsed: Math.round(t - this.startAt),
      remaining: Math.round(this.endAt - t),
      duration: this.endAt - this.startAt
    };
  }
  obs() {
    return this.ticker;
  }
  get current() {
    return this.recalc(pnow());
  }
  _update(step) {
    if (!step.running) {
      this.running = false;
      this.ticker.next(void 0);
      return;
    }
    if (step.elapsed === null || step.remaining === null || step.elapsed === void 0 || step.remaining === void 0) {
      this.running = false;
      return;
    }
    const now = pnow();
    this.startAt = now - step.elapsed * 1e3;
    this.endAt = now + step.remaining * 1e3;
    this.running = step.elapsed >= 0 && step.remaining >= 0;
    this.ticker.next(this.recalc(now));
  }
  _stop() {
    this.running = false;
    this.ticker.next(void 0);
  }
};
var Steps = class {
  constructor(stepsObs, donesObs) {
    this.steps = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    this._hadUpdates = false;
    stepsObs.subscribe({
      next: ({ step, removed }) => {
        this.update(step, removed);
      }
    });
    donesObs.subscribe({
      next: () => {
        this.next();
      }
    });
    this.ticker = new import_rxjs5.BehaviorSubject(Math.floor(pnow()));
    const controller = new AbortController();
    timerInterval(1e3, controller.signal, (t) => {
      this.ticker.next(t);
    });
  }
  step(stepID) {
    return this.steps.get(stepID);
  }
  hadUpdates() {
    const hadUpdates = this._hadUpdates;
    this._hadUpdates = false;
    return hadUpdates;
  }
  update(step, removed) {
    if (removed) {
      this.updates.set(step.id, true);
    } else {
      this.updates.set(step.id, step);
    }
    this._hadUpdates = true;
  }
  next() {
    for (const [id, stepOrDel] of this.updates) {
      let step = this.steps.get(id);
      if (typeof stepOrDel === "boolean") {
        if (step) {
          step._stop();
          this.steps.delete(id);
        }
      } else {
        if (!step) {
          step = new Step(stepOrDel, this.ticker);
          this.steps.set(id, step);
        }
        step._update(stepOrDel);
      }
    }
    this.updates.clear();
  }
};
var root = typeof self === "object" && self.self == self ? self : typeof global === "object" && global.global == global ? global : {};
if (!root["requestAnimationFrame"]) {
  root["requestAnimationFrame"] = (cb) => cb(pnow());
}
function timerInterval(ms = 1e3, signal, callback) {
  const start = Math.floor(pnow() / 1e3) * 1e3;
  function frame(time) {
    if (signal.aborted)
      return;
    callback(time);
    scheduleFrame(time);
  }
  function scheduleFrame(time) {
    const elapsed = time - start;
    const roundedElapsed = Math.round(elapsed / ms) * ms;
    const targetNext = start + roundedElapsed + ms;
    const delay = targetNext - pnow();
    timeout(() => requestAnimationFrame(frame), delay);
  }
  scheduleFrame(start);
}

// src/player/utils.ts
var isDevelopment = process.env.NODE_ENV === "development";
var isProduction = process.env.NODE_ENV === "production";
var isTest = process.env.NODE_ENV === "test";
var createNewParticipant = (key = "participantKey") => {
  var _a;
  const url = new URL(document.location.href);
  url.searchParams.set(key, new Date().getTime().toString());
  (_a = window.open(url.href, "_blank")) == null ? void 0 : _a.focus();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Attribute,
  Attributes,
  Globals,
  Scope,
  Scopes,
  Step,
  Steps,
  TajribaProvider,
  createNewParticipant,
  isDevelopment,
  isProduction,
  isTest
});
//# sourceMappingURL=player.cjs.map