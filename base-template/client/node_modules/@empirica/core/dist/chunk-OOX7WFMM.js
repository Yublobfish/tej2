import {
  Scope,
  Scopes
} from "./chunk-TSO4LTDH.js";

// src/admin/events.ts
var TajribaEvent = /* @__PURE__ */ ((TajribaEvent2) => {
  TajribaEvent2["TransitionAdd"] = "TRANSITION_ADD";
  TajribaEvent2["ParticipantConnect"] = "PARTICIPANT_CONNECT";
  TajribaEvent2["ParticipantDisconnect"] = "PARTICIPANT_DISCONNECT";
  return TajribaEvent2;
})(TajribaEvent || {});
var placementString = /* @__PURE__ */ new Map();
placementString.set(0 /* Before */, "before");
placementString.set(1 /* None */, "on");
placementString.set(2 /* After */, "after");
function PlacementString(placement) {
  return placementString.get(placement);
}
function unique(kind, placement, callback) {
  return async (ctx, props) => {
    const attr = props.attribute;
    const scope = props[kind];
    if (!attr.id || scope.get(`ran-${attr.id}`)) {
      return;
    }
    await callback(ctx, props);
    scope.set(`ran-${PlacementString(placement)}-${attr.id}`, true);
  };
}
var ListenersCollector = class {
  constructor() {
    this.starts = [];
    this.readys = [];
    this.tajEvents = [];
    this.kindListeners = [];
    this.attributeListeners = [];
  }
  get unique() {
    return new ListenersCollectorProxy(this);
  }
  on(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback) {
    this.registerListerner(
      1 /* None */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback
    );
  }
  before(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall) {
    this.registerListerner(
      0 /* Before */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      uniqueCall
    );
  }
  after(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall) {
    this.registerListerner(
      2 /* After */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      uniqueCall
    );
  }
  registerListerner(placement, kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall = false) {
    if (kindOrEvent === "start") {
      if (callback) {
        throw new Error("start event only accepts 2 arguments");
      }
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.starts.push({
        placement,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (kindOrEvent === "ready") {
      if (callback) {
        throw new Error("ready event only accepts 2 arguments");
      }
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.readys.push({
        placement,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (Object.values(TajribaEvent).includes(kindOrEvent)) {
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.tajEvents.push({
        placement,
        event: kindOrEvent,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (typeof keyOrNodeIDOrEventOrCallback === "function") {
      this.kindListeners.push({
        placement,
        kind: kindOrEvent,
        callback: keyOrNodeIDOrEventOrCallback
      });
    } else {
      if (typeof keyOrNodeIDOrEventOrCallback !== "string") {
        throw new Error("second argument expected to be an attribute key");
      }
      if (typeof callback !== "function") {
        throw new Error("third argument expected to be a callback");
      }
      if (uniqueCall) {
        callback = unique(kindOrEvent, placement, callback);
      }
      this.attributeListeners.push({
        placement,
        kind: kindOrEvent,
        key: keyOrNodeIDOrEventOrCallback,
        callback
      });
    }
  }
};
var ListenersCollectorProxy = class extends ListenersCollector {
  constructor(coll) {
    super();
    this.coll = coll;
  }
  registerListerner(placement, kindOrEvent, keyOrNodeIDOrEventOrCallback, callback) {
    if (kindOrEvent === "start" || kindOrEvent === "ready" || Object.values(TajribaEvent).includes(kindOrEvent) || typeof keyOrNodeIDOrEventOrCallback === "function") {
      throw new Error("only attribute listeners can be unique");
    }
    super.registerListerner(
      placement,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      true
    );
    while (true) {
      const listener = this.attributeListeners.pop();
      if (!listener) {
        break;
      }
      this.coll.attributeListeners.push(listener);
    }
  }
};
var EventContext = class {
  constructor(subs, taj, scopes) {
    this.subs = subs;
    this.taj = taj;
    this.scopes = scopes;
  }
  scopesByKind(kind) {
    return this.scopes.byKind(kind);
  }
  scopesByKindID(kind, id) {
    return this.scopes.byKind(kind).get(id);
  }
  scopesByKindMatching(kind, key, val) {
    const scopes = Array.from(this.scopes.byKind(kind).values());
    return scopes.filter((s) => s.get(key) === val);
  }
  scopeSub(...inputs) {
    for (const input of inputs) {
      this.subs.scopeSub(input);
    }
  }
  participantsSub() {
    this.subs.participantsSub();
  }
  transitionsSub(stepID) {
    this.subs.transitionsSub(stepID);
  }
  addScopes(input) {
    return this.taj.addScopes(input);
  }
  addGroups(input) {
    return this.taj.addGroups(input);
  }
  addLinks(input) {
    return this.taj.addLinks(input);
  }
  addSteps(input) {
    return this.taj.addSteps(input);
  }
  addTransitions(input) {
    return this.taj.addTransitions(input);
  }
  addFinalizer(cb) {
    this.taj.addFinalizer(cb);
  }
  get globals() {
    return this.taj.globals;
  }
};

// src/admin/scopes.ts
import { ReplaySubject } from "rxjs";
var Scopes2 = class extends Scopes {
  constructor(scopesObs, donesObs, ctx, kinds, attributes, taj) {
    super(scopesObs, donesObs, ctx, kinds, attributes);
    this.taj = taj;
    this.kindSubs = /* @__PURE__ */ new Map();
  }
  subscribeKind(kind) {
    let sub = this.kindSubs.get(kind);
    if (!sub) {
      sub = new ReplaySubject();
      this.kindSubs.set(kind, sub);
      const scopes = this.byKind(kind);
      setTimeout(() => {
        let count = 0;
        for (const [_, scope] of scopes) {
          count++;
          sub.next({ scope, done: scopes.size === count });
        }
        if (scopes.size === 0) {
          sub.next({ done: scopes.size === count });
        }
      }, 0);
    }
    return sub;
  }
  next() {
    for (const [_, scopeReplaySubject] of this.scopes) {
      const scope = scopeReplaySubject.getValue();
      if (scope._updated) {
        const kindSub = this.kindSubs.get(scope.kind);
        if (kindSub) {
          kindSub.next({ scope, done: true });
        }
      }
    }
    super.next();
  }
  create(scopeClass, scope) {
    return new scopeClass(this.ctx, scope, this, this.attributes);
  }
};
var Scope2 = class extends Scope {
  constructor(ctx, scope, scopes, attributes) {
    super(ctx, scope, attributes);
    this.scopes = scopes;
    this.taj = scopes.taj;
  }
  scopeByID(id) {
    return this.scopes.scope(id);
  }
  scopeByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.scopes.scope(id);
  }
  scopesByKind(kind) {
    return this.scopes.byKind(kind);
  }
  scopesByKindID(kind, id) {
    return this.scopes.byKind(kind).get(id);
  }
  scopesByKindMatching(kind, key, val) {
    const scopes = Array.from(this.scopes.byKind(kind).values());
    return scopes.filter((s) => s.get(key) === val);
  }
  addScopes(input) {
    return this.taj.addScopes(input);
  }
  addGroups(input) {
    return this.taj.addGroups(input);
  }
  addLinks(input) {
    return this.taj.addLinks(input);
  }
  addSteps(input) {
    return this.taj.addSteps(input);
  }
  addTransitions(input) {
    return this.taj.addTransitions(input);
  }
  addFinalizer(cb) {
    this.taj.addFinalizer(cb);
  }
  get globals() {
    return this.taj.globals;
  }
};

// src/admin/promises.ts
function promiseHandle() {
  let ret = {};
  ret.promise = new Promise((r) => {
    ret.result = r;
  });
  return ret;
}

export {
  TajribaEvent,
  ListenersCollector,
  EventContext,
  promiseHandle,
  Scopes2 as Scopes,
  Scope2 as Scope
};
//# sourceMappingURL=chunk-OOX7WFMM.js.map