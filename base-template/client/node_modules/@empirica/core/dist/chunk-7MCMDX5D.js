import {
  promiseHandle
} from "./chunk-OOX7WFMM.js";
import {
  Attributes
} from "./chunk-JQF6FVSM.js";
import {
  ErrNotConnected,
  subscribeAsync
} from "./chunk-KMJOEJJN.js";
import {
  bs,
  bsu
} from "./chunk-BNOCSFZ7.js";
import {
  error,
  warn
} from "./chunk-I6L7V5LM.js";

// src/admin/attributes.ts
import { ReplaySubject } from "rxjs";
var Attributes2 = class extends Attributes {
  constructor() {
    super(...arguments);
    this.attrsByKind = /* @__PURE__ */ new Map();
    this.attribSubs = /* @__PURE__ */ new Map();
  }
  subscribeAttribute(kind, key) {
    if (!this.attribSubs.has(kind)) {
      this.attribSubs.set(kind, /* @__PURE__ */ new Map());
    }
    const keyMap = this.attribSubs.get(kind);
    let sub = keyMap.get(key);
    if (!sub) {
      sub = new ReplaySubject();
      keyMap.set(key, sub);
      const attrByScopeID = this.attrsByKind.get(kind);
      setTimeout(() => {
        if (!attrByScopeID) {
          sub.next({ done: true });
          return;
        }
        let attrs = [];
        for (const [_, attrByKey] of attrByScopeID == null ? void 0 : attrByScopeID.entries()) {
          for (const [_2, attr] of attrByKey) {
            if (attr.key === key) {
              attrs.push(attr);
            }
          }
        }
        if (attrs.length > 0) {
          let count = 0;
          for (const attr of attrs) {
            count++;
            sub.next({ attribute: attr, done: count == attrs.length });
          }
        } else {
          sub.next({ done: true });
        }
      }, 0);
    }
    return sub;
  }
  next() {
    var _a, _b, _c;
    const byKind = /* @__PURE__ */ new Map();
    for (const [_, attrs] of this.updates) {
      for (const [_2, attr] of attrs) {
        if (typeof attr === "boolean") {
          continue;
        }
        const kind = (_a = attr.node) == null ? void 0 : _a.kind;
        if (kind) {
          let kindAttrs = byKind.get(kind);
          if (!kindAttrs) {
            kindAttrs = [];
            byKind.set(kind, kindAttrs);
          }
          kindAttrs.push(attr);
        }
      }
    }
    const updates = [];
    for (const [kind, attrs] of byKind) {
      for (const attr of attrs) {
        if (!attr.nodeID && !((_b = attr.node) == null ? void 0 : _b.id)) {
          warn(`found attribute change without node ID`);
          continue;
        }
        updates.push([kind, attr.key, attr]);
      }
    }
    super.next();
    for (const [kind, key, attrChange] of updates) {
      const nodeID = attrChange.nodeID || attrChange.node.id;
      const attr = this.attrs.get(nodeID).get(key);
      const sub = (_c = this.attribSubs.get(kind)) == null ? void 0 : _c.get(key);
      if (sub) {
        sub.next({ attribute: attr, done: true });
      } else {
        let kAttrs = this.attrsByKind.get(kind);
        if (!kAttrs) {
          kAttrs = /* @__PURE__ */ new Map();
          this.attrsByKind.set(kind, kAttrs);
        }
        let kkAttrs = kAttrs.get(nodeID);
        if (!kkAttrs) {
          kkAttrs = /* @__PURE__ */ new Map();
          kAttrs.set(nodeID, kkAttrs);
        }
        kkAttrs.set(key, attr);
      }
    }
  }
};

// src/admin/connection.ts
import { merge } from "rxjs";
var AdminConnection = class {
  constructor(taj, tokens, resetToken) {
    this.resetToken = resetToken;
    this._tajriba = bsu();
    this._connected = bs(false);
    this._connecting = bs(false);
    this._stopped = bs(false);
    let token;
    let connected = false;
    this.sub = subscribeAsync(
      merge(taj.connected, tokens),
      async (tokenOrConnected) => {
        if (typeof tokenOrConnected === "boolean") {
          connected = tokenOrConnected;
        } else {
          token = tokenOrConnected;
        }
        if (!token || !connected) {
          return;
        }
        if (this._connected.getValue()) {
          return;
        }
        this._connecting.next(true);
        try {
          const tajAdmin = await taj.sessionAdmin(token);
          this._tajriba.next(tajAdmin);
          this._connected.next(true);
          tajAdmin.on("connected", () => {
            if (!this._connected.getValue()) {
              this._connected.next(true);
            }
          });
          tajAdmin.on("disconnected", () => {
            if (this._connected.getValue()) {
              this._connected.next(false);
            }
          });
          tajAdmin.on("accessDenied", () => {
            if (this._connected.getValue()) {
              this._connected.next(false);
            }
            this.resetToken();
          });
        } catch (error2) {
          if (error2 !== ErrNotConnected) {
            this.resetToken();
          }
        }
        this._connecting.next(false);
      }
    );
  }
  stop() {
    if (this._stopped.getValue()) {
      return;
    }
    const taj = this._tajriba.getValue();
    if (taj) {
      taj.removeAllListeners("connected");
      taj.removeAllListeners("disconnected");
      taj.stop();
      this._tajriba.next(void 0);
    }
    this.sub.unsubscribe();
    this._connecting.next(false);
    this._connected.next(false);
    this._stopped.next(true);
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  get stopped() {
    return this._stopped;
  }
  get admin() {
    return this._tajriba;
  }
};

// src/admin/participants.ts
import { EventType } from "@empirica/tajriba";
async function participantsSub(taj, connections, participants) {
  let handle = promiseHandle();
  taj.onEvent({ eventTypes: [EventType.ParticipantConnected] }).subscribe({
    next({ node, done }) {
      if (!node) {
        if (done) {
          if (handle) {
            handle == null ? void 0 : handle.result();
            connections.next({ done: true });
          }
          return;
        }
        error(`received no participant on connected`);
        return;
      }
      if (node.__typename !== "Participant") {
        error(`received non-participant on connected`);
        return;
      }
      const part = {
        id: node.id,
        identifier: node.identifier
      };
      participants.set(node.id, part);
      connections.next({
        connection: {
          participant: part,
          connected: true
        },
        done
      });
      if (handle && done) {
        handle.result();
      }
    }
  });
  taj.onEvent({ eventTypes: [EventType.ParticipantDisconnect] }).subscribe({
    next({ node }) {
      if (!node) {
        error(`received no participant on disconnect`);
        return;
      }
      if (node.__typename !== "Participant") {
        error(`received non-participant on disconnect`);
        return;
      }
      participants.delete(node.id);
      connections.next({
        connection: {
          participant: {
            id: node.id,
            identifier: node.identifier
          },
          connected: false
        },
        done: true
      });
    }
  });
  await handle.promise;
  handle = void 0;
}

// src/admin/subscriptions.ts
function kvstr(kv) {
  return kv.key + "-" + kv.val;
}
var Subscriptions = class {
  constructor() {
    this.scopeKinds = /* @__PURE__ */ new Set();
    this.scopeIDs = /* @__PURE__ */ new Set();
    this.scopeNames = /* @__PURE__ */ new Set();
    this.scopeKeys = /* @__PURE__ */ new Set();
    this.scopeKVSet = /* @__PURE__ */ new Set();
    this.scopeKVs = [];
    this.participantSub = false;
    this.transitionsSubs = /* @__PURE__ */ new Set();
    this.dirty = false;
    this.last = {
      participants: false,
      scopes: {
        ids: [],
        kinds: [],
        names: [],
        keys: [],
        kvs: []
      },
      transitions: []
    };
  }
  get subs() {
    return {
      participants: this.participantSub,
      scopes: {
        kinds: Array.from(this.scopeKinds.values()),
        ids: Array.from(this.scopeIDs.values()),
        names: Array.from(this.scopeNames.values()),
        keys: Array.from(this.scopeKeys.values()),
        kvs: [...this.scopeKVs]
      },
      transitions: Array.from(this.transitionsSubs.values())
    };
  }
  newSubs() {
    if (!this.dirty) {
      return;
    }
    const current = this.subs;
    const {
      scopes: { ids, kinds, names, keys, kvs },
      participants,
      transitions
    } = this.last;
    const kvsstrs = kvs.map((kv) => kvstr(kv));
    const next = {
      participants: this.participantSub && !participants,
      scopes: {
        ids: current.scopes.ids.filter((id) => !ids.includes(id)),
        kinds: current.scopes.kinds.filter((kind) => !kinds.includes(kind)),
        names: current.scopes.names.filter((name) => !names.includes(name)),
        keys: current.scopes.keys.filter((key) => !keys.includes(key)),
        kvs: current.scopes.kvs.filter((kv) => !kvsstrs.includes(kvstr(kv)))
      },
      transitions: current.transitions.filter(
        (id) => !transitions.includes(id)
      )
    };
    this.last = current;
    this.dirty = false;
    return next;
  }
  scopeSub(input) {
    if (input.ids) {
      for (const id of input.ids) {
        if (!this.scopeIDs.has(id)) {
          this.scopeIDs.add(id);
          this.dirty = true;
        }
      }
    }
    if (input.kinds) {
      for (const id of input.kinds) {
        if (!this.scopeKinds.has(id)) {
          this.scopeKinds.add(id);
          this.dirty = true;
        }
      }
    }
    if (input.names) {
      for (const name of input.names) {
        if (!this.scopeNames.has(name)) {
          this.scopeNames.add(name);
          this.dirty = true;
        }
      }
    }
    if (input.keys) {
      for (const key of input.keys) {
        if (!this.scopeKeys.has(key)) {
          this.scopeKeys.add(key);
          this.dirty = true;
        }
      }
    }
    if (input.kvs) {
      for (const kv of input.kvs) {
        const kvKey = kvstr(kv);
        if (!this.scopeKVSet.has(kvKey)) {
          this.scopeKVSet.add(kvKey);
          this.scopeKVs.push(kv);
          this.dirty = true;
        }
      }
    }
  }
  participantsSub() {
    if (!this.participantSub) {
      this.dirty = true;
      this.participantSub = true;
    }
  }
  transitionsSub(nodeID) {
    if (!this.transitionsSubs.has(nodeID)) {
      this.transitionsSubs.add(nodeID);
      this.dirty = true;
    }
  }
};

// src/admin/transitions.ts
import { EventType as EventType2 } from "@empirica/tajriba";
function transitionsSub(taj, transitions, nodeID) {
  taj.onEvent({ eventTypes: [EventType2.TransitionAdd], nodeID }).subscribe({
    next({ node }) {
      if (!node) {
        return;
      }
      if (node.__typename !== "Transition") {
        error(`received non-transition`);
        return;
      }
      if (node.node.__typename !== "Step") {
        error(`received non-step transition`, node.node);
        return;
      }
      transitions.next({
        id: node.id,
        to: node.to,
        from: node.from,
        step: {
          id: node.node.id,
          duration: node.node.duration,
          state: node.node.state
        }
      });
    }
  });
}

export {
  Attributes2 as Attributes,
  AdminConnection,
  participantsSub,
  Subscriptions,
  transitionsSub
};
//# sourceMappingURL=chunk-7MCMDX5D.js.map