import {
  bs
} from "./chunk-BNOCSFZ7.js";
import {
  warn
} from "./chunk-I6L7V5LM.js";

// src/shared/tajriba_connection.ts
import { Tajriba } from "@empirica/tajriba";
var ErrNotConnected = new Error("not connected");
var TajribaConnection = class {
  constructor(url) {
    this.url = url;
    this._connected = bs(false);
    this._connecting = bs(true);
    this._stopped = bs(false);
    this.tajriba = Tajriba.connect(this.url);
    this._connected.next(this.tajriba.connected);
    this.tajriba.on("connected", () => {
      this._connected.next(true);
      this._connecting.next(false);
    });
    this.tajriba.on("disconnected", () => {
      this._connected.next(false);
      this._connecting.next(true);
    });
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  get stopped() {
    return this._stopped;
  }
  async sessionParticipant(token, pident) {
    if (!this._connected.getValue()) {
      throw ErrNotConnected;
    }
    return await this.tajriba.sessionParticipant(token, pident);
  }
  async sessionAdmin(token) {
    if (!this._connected.getValue()) {
      throw ErrNotConnected;
    }
    return await this.tajriba.sessionAdmin(token);
  }
  stop() {
    if (this._stopped.getValue()) {
      return;
    }
    if (this.tajriba) {
      this.tajriba.removeAllListeners("connected");
      this.tajriba.removeAllListeners("disconnected");
      this.tajriba.stop();
    }
    this._connecting.next(false);
    this._connected.next(false);
    this._stopped.next(true);
  }
};

// src/admin/observables.ts
import { Subject, concatMap, takeUntil } from "rxjs";
async function awaitObsValue(obs, value) {
  let res;
  const prom = new Promise((r) => {
    res = r;
  });
  const unsub = obs.subscribe((val2) => {
    if (val2 === value) {
      res(val2);
    }
  });
  const val = await prom;
  unsub.unsubscribe();
  return val;
}
function subscribeAsync(obs, fn) {
  const cancel = new Subject();
  obs.pipe(concatMap(fn), takeUntil(cancel)).subscribe();
  return {
    closed: false,
    unsubscribe() {
      if (this.closed) {
        warn("closing a closed async observable subscription");
        return;
      }
      this.closed = true;
      cancel.next();
      cancel.unsubscribe();
    }
  };
}

export {
  ErrNotConnected,
  TajribaConnection,
  awaitObsValue,
  subscribeAsync
};
//# sourceMappingURL=chunk-KMJOEJJN.js.map