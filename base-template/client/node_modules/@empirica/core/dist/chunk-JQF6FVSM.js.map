{"version":3,"sources":["../src/shared/attributes.ts"],"sourcesContent":["import { SetAttributeInput } from \"@empirica/tajriba\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { error, trace } from \"../utils/console\";\nimport { JsonValue } from \"../utils/json\";\n\nexport interface AttributeChange {\n  /** deleted is true with the attribute was deleted. */\n  deleted?: boolean;\n  /** deletedAt is the time when the Attribute was deleted. int64 Date + Time\n   * value given in Epoch with ns precision */\n  deletedAt?: number;\n  /** id is the identifier for the Attribute. */\n  id: string;\n  /** index is the index of the attribute if the value is a vector. */\n  index?: number | null;\n  /** isNew is true if the Attribute was just created. */\n  isNew?: boolean;\n  /** key is the attribute key being updated. */\n  key: string;\n  /** nodeID is the identifier for the Attribute's Node. */\n  nodeID?: string;\n  /** node is the Attribute's Node. */\n  node?: {\n    __typename: \"Scope\";\n    id: string;\n    kind?: string;\n    name?: string;\n  };\n  /** value is the value of the updated attribute. */\n  val?: string | null;\n  /** vector indicates whether the value is a vector. */\n  vector: boolean;\n  /** version is the version number of this Attribute, starting at 1. */\n  version: number;\n}\n\nexport interface AttributeUpdate {\n  attribute: AttributeChange;\n  removed: boolean;\n}\n\nexport class Attributes {\n  protected attrs = new Map<string, Map<string, Attribute>>();\n  protected updates = new Map<string, Map<string, AttributeChange | boolean>>();\n\n  constructor(\n    attributesObs: Observable<AttributeUpdate>,\n    donesObs: Observable<void>,\n    readonly setAttributes: (input: SetAttributeInput[]) => Promise<unknown>\n  ) {\n    attributesObs.subscribe({\n      next: ({ attribute, removed }) => {\n        this.update(attribute, removed);\n      },\n    });\n\n    donesObs.subscribe({\n      next: this.next.bind(this),\n    });\n  }\n\n  attribute(scopeID: string, key: string): Attribute {\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.attrs.set(scopeID, scopeMap);\n    }\n\n    let attr = scopeMap.get(key);\n    if (!attr) {\n      attr = new Attribute(this.setAttributes, scopeID, key);\n      scopeMap.set(key, attr);\n    }\n\n    return attr;\n  }\n\n  attributes(scopeID: string): Attribute[] {\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.attrs.set(scopeID, scopeMap);\n    }\n\n    return Array.from(scopeMap.values());\n  }\n\n  attributePeek(scopeID: string, key: string): Attribute | undefined {\n    let scopeUpdateMap = this.updates.get(scopeID);\n    if (scopeUpdateMap) {\n      const updated = scopeUpdateMap.get(key);\n      if (updated) {\n        if (typeof updated === \"boolean\") {\n          return;\n        } else {\n          if (!updated.val) {\n            return;\n          } else {\n            const attr = new Attribute(this.setAttributes, scopeID, key);\n            attr._update(updated);\n            return attr;\n          }\n        }\n      }\n    }\n\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      return;\n    }\n\n    let attr = scopeMap.get(key);\n    if (!attr) {\n      return;\n    }\n\n    if (attr.value === undefined) {\n      return;\n    }\n\n    return attr;\n  }\n\n  nextAttributeValue(scopeID: string, key: string): JsonValue | undefined {\n    const attr = this.attributePeek(scopeID, key);\n    if (!attr) {\n      return;\n    }\n\n    return attr.value;\n  }\n\n  private update(attr: AttributeChange, removed: boolean) {\n    let nodeID = attr.nodeID;\n    if (!nodeID) {\n      if (!attr.node?.id) {\n        error(`new attribute without node ID`);\n        return;\n      }\n      nodeID = attr.node.id;\n    }\n\n    let scopeMap = this.updates.get(nodeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.updates.set(nodeID, scopeMap);\n    }\n\n    if (removed) {\n      scopeMap.set(attr.key, true);\n    } else {\n      scopeMap.set(attr.key, attr);\n    }\n  }\n\n  scopeWasUpdated(scopeID?: string): boolean {\n    if (!scopeID) {\n      return false;\n    }\n\n    return this.updates.has(scopeID);\n  }\n\n  protected next() {\n    for (const [scopeID, attrs] of this.updates) {\n      let scopeMap = this.attrs.get(scopeID);\n\n      if (!scopeMap) {\n        scopeMap = new Map();\n        this.attrs.set(scopeID, scopeMap);\n      }\n\n      for (const [key, attrOrDel] of attrs) {\n        let attr = scopeMap.get(key);\n        if (typeof attrOrDel === \"boolean\") {\n          if (attr) {\n            attr._update(undefined);\n          }\n        } else {\n          if (!attr) {\n            attr = new Attribute(this.setAttributes, scopeID, key);\n            scopeMap.set(key, attr);\n          }\n\n          attr._update(attrOrDel);\n        }\n      }\n    }\n\n    this.updates.clear();\n  }\n}\n\nexport interface AttributeOptions {\n  /**\n   * Private indicates the attribute will not be visible to other Participants.\n   */\n  private: boolean;\n  /**\n   * Protected indicates the attribute will not be updatable by other\n   * Participants.\n   */\n  protected: boolean;\n  /** Immutable creates an Attribute that cannot be updated. */\n  immutable: boolean;\n  /** Vector indicates the value is a vector. */\n  vector: boolean;\n  /**\n   * Index, only used if the Attribute is a vector, indicates which index to\n   * update the value at.\n   */\n  index: number | null;\n  /**\n   * Append, only used if the Attribute is a vector, indicates to append the\n   * attribute to the vector.\n   */\n  append: boolean | null;\n}\n\nexport class Attribute {\n  private attr?: AttributeChange;\n  private val = new BehaviorSubject<JsonValue | undefined>(undefined);\n\n  constructor(\n    private setAttributes: (input: SetAttributeInput[]) => Promise<unknown>,\n    readonly scopeID: string,\n    readonly key: string\n  ) {}\n\n  get id() {\n    return this.attr?.id;\n  }\n\n  get obs(): Observable<JsonValue | undefined> {\n    return this.val;\n  }\n\n  get value() {\n    return this.val.getValue();\n  }\n\n  get nodeID() {\n    return this.attr?.nodeID || this.attr?.node?.id;\n  }\n\n  set(value: JsonValue, ao?: Partial<AttributeOptions>) {\n    this.val.next(value);\n\n    const attrProps: SetAttributeInput = {\n      key: this.key,\n      nodeID: this.scopeID,\n      val: JSON.stringify(value),\n    };\n\n    if (ao) {\n      // TODO Fix this. Should check if compatible with existing attribute and\n      // only set fields set on ao.\n      attrProps.private = ao.private;\n      attrProps.protected = ao.protected;\n      attrProps.immutable = ao.immutable;\n      attrProps.append = ao.append;\n      attrProps.vector = ao.vector;\n      attrProps.index = ao.index;\n    }\n\n    this.setAttributes([attrProps]);\n    trace(`SET ${this.key} = ${value} (${this.scopeID})`);\n  }\n\n  // internal only\n  _update(attr?: AttributeChange) {\n    if (attr && this.attr && this.attr.id === attr.id) {\n      return;\n    }\n\n    this.attr = attr;\n    let value: JsonValue | undefined = undefined;\n    if (this.attr?.val) {\n      value = JSON.parse(this.attr.val);\n    }\n    this.val.next(value);\n  }\n}\n"],"mappings":"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","names":["attr"]}